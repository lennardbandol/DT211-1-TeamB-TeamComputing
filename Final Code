#pragma config(Sensor, S1,     lightsensor,    sensorLightActive)
#pragma config(Sensor, S2,     touchsensor,    sensorTouch)
#pragma config(Sensor, S3,     soundsensor,    sensorSoundDB)
#pragma config(Sensor, S4,     sonarsensor,    sensorSONAR)
#pragma config(Motor,  motorB,          rightmotor,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          leftmotor,     tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*

		Team Computing Project - Team B
		Lennard Glenn Bandol & Tim Browning
		29/04/2015
		
		---------------functions needed------------------
		done - accurate turning left / right / forward
		done - avoid black cells 
		done - navigate the map 
		done - prevent the object from moving outside of the map
		done - robot position function
		done - record position
		done - find objects using the sonarsensor
		done - move back to start
		done - go to the object
		
*/

//checks wether the cell is black or not.
int check_cell( int threshold);
//updates the map if it detects a black cell.
void update_map( int current_x, int current_y, int direction );
//updates the map if it detects the object.
void update_map_for_object( int current_x, int current_y, int direction, int no_of_blocks );
//function to move back to the start position.
void move_to_start();
//function to detect the object using sonar sensor
void detect_objects( int no_of_blocks );
//function to check all sides for the objects.
void check_all_sides();
//function to find the shortest route to the object.
void shortest_route();

//functions for movement
void turnleft();
void turnright();
void forward();
void change_direction(); //choose left / right randomly
void change_coordinates(); // change the coordinates after it moved.
void check_edge(); //checks wether the robot is on the edge of the grid.
void navigate(); //Moves around the map using most of the other functions for movement.

// ************GLOBAL VARIABLES ************

//Finding Thresh Hold Value.
int lightValue;
int darkValue;
int sumValue;
int thresholdValue;
int sonarvalue = 101;

//Robot Starting Status: starts at 0,4 Facing North;#
int grid[7][9];
int current_x = 4;
int current_y = 0;
int direction = 0;
int random_var = 0;
int speed = 40;
int no_of_blocks;
int found_objects = 0;
int i,j;

task main()
{

	//finds the threshold value
	darkValue=28;
	lightValue=65;
	sumValue = lightValue + darkValue;
	thresholdValue = sumValue/2;

	//balance the wheels
	nMotorPIDSpeedCtrl[rightmotor] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[leftmotor] = mtrSpeedReg;


	/*

	North = Direction = 0

	West = Direction = 1

	South = Direction = 2

	East = Direction = 3

	************** GRID **************

	0 = White Cells
	1 = Black Cells
	2 = Objects.
	99 = Start

	*/


	//Makes the turning even when it moves.


	// initialising the grid
	for ( i = 0; i < 9; i++)
	{
		for ( j = 0; i < 7 ; i ++)
		{
			grid[i][j] = 0;
		}
	}

	grid[4][0] = 99;

	while( found_objects < 2 )
	{
		navigate();
	}
	
	wait1Msec(2000);

	move_to_start();
	
	wait1Msec(2000);
	
	shortest_route();

}//end main

//checks the cell colour
int check_cell( int threshold )
{
	if (SensorValue(lightsensor) < threshold)
	{
		return 1;
	}
	else
	{
		return 0;
	} //end else
}//end check_cell

//updates the map for black cells
void update_map( int current_x, int current_y, int direction )
{
	if (direction == 0)
	{

		//Facing north, so row above, same column is black
		grid[current_x][current_y+1] = 1;

	}//end if

	else if (direction == 1)
	{

		//Facing west, so same row, previous column is black
		grid[current_x-1][current_y] = 1;

	}//end else

	else if (direction == 2)
	{

		//Facing south, so row below, same column is black
		grid[current_x][current_y-1] = 1;

	}//end else if

	else if (direction == 3)
	{

		//Facing east, so same row, next column is black
		grid[current_x+1][current_y] = 1;

	}//end else if

}//end update_map

void update_map_for_object( int current_x, int current_y, int direction, int no_of_blocks )
{
	if (direction == 0)
	{

		//Facing north, so row above, same column is object
		grid[current_x][current_y+no_of_blocks] = 2 ;

	}//end if

	else if (direction == 1)
	{

		//Facing west, so same row, previous column is object
		grid[current_x-no_of_blocks][current_y] = 2;

	}//end else

	else if (direction == 2)
	{

		//Facing south, so row below, same column is object
		grid[current_x][current_y-no_of_blocks] = 2;

	}//end else if

	else if (direction == 3)
	{

		//Facing east, so same row, next column is the object
		grid[current_x+no_of_blocks][current_y] = 2;

	}//end else if

} //end update_map for object

//function to turn left
void turnleft()
{

	nMotorEncoder[rightmotor] = 0;
	while(nMotorEncoder[rightmotor] < 175)
	{

		motor[leftmotor] = -speed;
		motor[rightmotor] = speed;

	} //end while

	motor[rightmotor] = 0;
	motor[leftmotor] = 0;
	wait1Msec(400);

}//end turnleft

//function to turn right
void turnright()
{

	nMotorEncoder[leftmotor] = 0;
	while(nMotorEncoder[leftmotor] < 175)
	{

		motor[leftmotor] = speed;
		motor[rightmotor] = -speed;

	} //end while

	motor[rightmotor] = 0;
	motor[leftmotor] = 0;
	wait1Msec(400);

}//end turn right

//function to move forward
void forward()
{

	nMotorEncoder[rightmotor] = 0;
	while(nMotorEncoder[rightmotor] < 270)
	{

		motor[leftmotor] = speed;
		motor[rightmotor] = speed;

	}//end while
	motor[rightmotor] = 0;
	motor[leftmotor] = 0;
	wait1Msec(500);

}//end forward

void change_direction()
{
	int cell_colour;
	//random function.
	random_var = rand() % 2 + 1;

	//if the random_var is 0 turn left
	if( random_var == 0 )
	{
		turnleft();
		direction++;

		//if direction is 4 it means it facing north so change the direction value to 0
		if( direction == 4 )
		{
			direction = 0;
		}//end inner if

		cell_colour = check_cell( thresholdValue );

		//if its detecting black cell change direction again.
		while(cell_colour == 1)
		{
			cell_colour = check_cell( thresholdValue );
			change_direction();
		}

	}//end if

	//if the random_var is 1 turn right
	if( random_var == 1 )
	{
		turnright();
		direction--;

		//if direction is -1 it means the the user is facing east changes the direction value to 3
		if(direction == -1 )
		{
			direction = 3;
		}//end inner if

		cell_colour = check_cell( thresholdValue );

		//if its detecting black cell change direction again.
		while(cell_colour == 1)
		{
			cell_colour = check_cell( thresholdValue );
			change_direction();
		}

	}//end if

}//end change direction

//function to move around the grid to find the objects,avoiding black cells and updating the map.
void navigate()
{
	int cell_colour;

	//checks the cells infront
	cell_colour = check_cell( thresholdValue );

	//checks the sonar sensor if its detecting an object
	check_all_sides();

	eraseDisplay();
	nxtDisplayString(1,"X: %d		Y: %d", current_x,current_y );
	nxtDisplayString(3,"Objects Found %d", found_objects );


	if (cell_colour == 1)
	{

		//before moving forward checks first if the robot is in the edge.
		check_edge();

		// Since Black cell was detected have to change th
		update_map(current_x, current_y, direction);

		//Need to avoid obstacle
		change_direction();

		//change coordinates
		change_coordinates();

		forward();
		
	}
	else
	{

		//before moving forward checks first if the robot is in the edge.
		check_edge();

		//change the current_x / current_y when it moves forward.
		change_coordinates();

		//moves forward.
		forward();

		eraseDisplay();
		nxtDisplayString(1,"X: %d		Y: %d", current_x,current_y );
		nxtDisplayString(3,"Objects Found %d", found_objects );

	}//end else

}//end navigate.

//check if the robot is on the edge of the grid.
void check_edge()
{
	while( direction == 0 && current_y == 8) //checks if at north edge & change direction if it is
	{
		//checks the direction of the robot
		change_direction();
		check_cell( thresholdValue );
	}

	while( direction == 1 && current_x == 0) //checks if at west edge & change direction if it is
	{
		//checks the direction of the robot
		change_direction();
		check_cell( thresholdValue );
	}

	while( direction == 2 && current_y == 0 ) //checks if at east edge & change direction if it is
	{
		//checks the direction of the robot
		change_direction();
		check_cell( thresholdValue );
	}

	while( direction == 3 && current_x == 6 ) //checks if at south edge & change direction if it is
	{
		//checks the direction of the robot
		change_direction();
		check_cell( thresholdValue );
	}
}

//change the coordinates of the robot when it moves forward.
void change_coordinates()
{
	if( direction == 0 ) //facing north
	{
		current_y++; //change y position
	}
	else if( direction == 1 ) //facing west
	{
		current_x--; //change x position
	}
	else if( direction == 2 ) //facing south
	{
		current_y--; //change y position
	}
	else if( direction == 3 ) //facing east.
	{
		current_x++; //change x position
	}
}

//function to move back to the start position
void move_to_start()
{

	//make the robot facing where the start position is
	while( direction != 2 )
	{
		turnleft();
		direction++;
		if( direction == 4 )
		{
			direction = 0;
		}
	}
	//while the robot is not on y axis of 0 forward
	while( current_y != 0 )
	{
		forward();
		change_coordinates();
	}
	//if the robot is on the x of less than 4 turn left.
	if( current_x < 4 )
	{
		turnleft();
		direction++;
		if( direction == 4 )
		{
			direction = 0;
		}
		while( current_x != 4 )
		{
			forward();
			change_coordinates();
		}
	}
	//else if the robot is on the x that is greater than 4 turn right.
	else if( current_x > 4 )
	{
		turnright();
		direction--;
		if( direction == -1 )
		{
			direction = 3 ;
		}
		while( current_x != 4 )
		{
			forward();
			change_coordinates();
		}
	}
	
	//make the robot turn north again.
	while( direction != 0 )
	{
		turnright();
		direction--;
		if( direction == -1 )
		{
			direction = 3 ;
		}
		while( current_x != 4 )
		{
			forward();
			change_coordinates();
		}//end inner while
	}//end while
}//end move_to_start.


//function to detect the objects using sonar sensor.
void detect_objects( int no_of_blocks )
{

	sonarvalue = SensorValue(sonarsensor);
	
	//if the object is less than a certain amount of distance it meants its X blocks away from the robot
	if( sonarvalue <= 20 )
	{
		no_of_blocks = 2;
		found_objects++;
		playSound(soundBeepBeep);
		update_map_for_object( current_x, current_y, direction, no_of_blocks );
	}
	else if( sonarvalue <= 30 )
	{
		no_of_blocks = 3;
		found_objects++;
		playSound(soundBeepBeep);
		update_map_for_object( current_x, current_y, direction, no_of_blocks );
	}
	else if( sonarvalue <= 40 )
	{
		no_of_blocks = 4;
		found_objects++;
		playSound(soundShortBlip);
		update_map_for_object( current_x, current_y, direction, no_of_blocks );
	}
	else if( sonarvalue <= 50 )
	{
		no_of_blocks = 5;
		found_objects++;
		playSound(soundShortBlip);
		update_map_for_object( current_x, current_y, direction, no_of_blocks );
	}
	else if( sonarvalue <= 60 )
	{
		no_of_blocks = 6;
		found_objects++;
		playSound(soundShortBlip);
		wait1Msec(500);
		update_map_for_object( current_x, current_y, direction, no_of_blocks );
	}
	else if( sonarvalue <= 70 )
	{
		no_of_blocks = 7;
		found_objects++;
		playSound(soundShortBlip);
		wait1Msec(500);
		update_map_for_object( current_x, current_y, direction, no_of_blocks );
	}

	wait1Msec(500);

}

void check_all_sides()
{
	turnleft();
	direction++;
	detect_objects( no_of_blocks );
	if( direction == 4 )
	{
		direction = 0;
	}
	turnright();
	direction--;
	detect_objects( no_of_blocks );
	if( direction == -1 )
	{
		direction = 3;
	}
	turnright();
	direction--;
	detect_objects( no_of_blocks );
	if( direction == -1 )
	{
		direction = 3;
	}
	turnleft();
	direction++;
	detect_objects( no_of_blocks );
	if( direction == 4 )
	{
		direction = 0;
	}
}

void shortest_route()
{
	//finds the coordinates of the objects then moves towards it.
	for(i = 0; i < 9; i++ )
	{
		for( j = 0; j < 7; j++ )
		{
			if( grid[i][j] == 2 )
			{
				
				//keep moving forward till its in the same row as the object
				while( current_y != j )
				{
					forward();
					change_coordinates();
				}
				
				//object is on the left side of the robot.
				if( i < current_x )
				{
					turnleft();
					direction++;
					if(direction == 4)
					{
						direction = 0;
					}
					while( current_x != i )
					{
						forward();
						change_coordinates();
					}
					move_to_start();
				}
				
				//object is on the right of the robot
				if( i > current_x )
				{
					turnright();
					direction--;
					//faces the object
					if( direction == -1 )
					{
						direction = 3;
					}
					
					//move forward till it hits the object
					while( current_x != i )
					{
						forward();
						change_coordinates();
					}
					//go back to start after finding the object
					move_to_start();
				}//end inner if
			}//end if
		}//end inner for
	}//end for
}//end shortest_route
