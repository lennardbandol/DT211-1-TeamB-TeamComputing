#pragma config(Sensor, S1,     lightsensor,    sensorLightActive)
#pragma config(Sensor, S2,     touchsensor,    sensorTouch)
#pragma config(Sensor, S4,     sonarsensor,    sensorSONAR)
#pragma config(Motor,  motorB,          rightmotor,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          leftmotor,     tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//checks wether the cell is black or not.
int check_cell( int threshold);
//updates the map if it detects a black cell.
void update_map( int current_x, int current_y, int direction );
//updates the map if it detects the object.
void update_map_for_object( int current_x, int current_y, int direction, int no_of_blocks );
//function to move back to the start position.
void move_to_start();
//function to detect the object using sonar sensor
void detect_objects( int no_of_blocks );
//function to check all sides.
void check_all_sides();
//function to print the map on the nxt display
void printmap();

//functions for movement
void turnleft();
void turnright();
void forward();
void change_direction(); //choose left / right randomly
void navigate(); //Moves around the map.
void check_edge(); //checks wether the robot is on the edge of the grid.
void change_coordinates(); // change the coordinates after it moved.
void check_touch(); 

// ************GLOBAL VARIABLES ************

//Finding Thresh Hold Value.
int lightValue;
int darkValue;
int sumValue;
int thresholdValue;
int sonarvalue = 101;

//Robot Starting Status: starts at 0,4 Facing North;#
int grid[7][9];
int current_x = 4;
int current_y = 0;
int direction = 0;
int random_var = 0;
int speed = 40;
int no_of_blocks;


int found_objects = 0;
int i,j;

task main()
{

	//finds the threshold value
	darkValue=28;
	lightValue=65;
	sumValue = lightValue + darkValue;
	thresholdValue = sumValue/2;

	//balance the wheels
	nMotorPIDSpeedCtrl[rightmotor] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[leftmotor] = mtrSpeedReg;


	/*

	North = Direction = 0

	West = Direction = 1

	South = Direction = 2

	East = Direction = 3

	************** GRID **************

	0 = White Cells
	1 = Black Cells
	2 = Objects.
	99 = Start

	*/


	//Makes the turning even when it moves.


	// initialising the grid
	for ( i = 0; i < 9; i++)
	{
		for ( j = 0; i < 7 ; i ++)
		{
			grid[i][j] = 0;
		}
	}

	grid[4][0] = 99;

	while( found_objects < 2 )
	{
		navigate();
	}
	
	move_to_start();

}

//checks the cell colour
int check_cell( int threshold )
{
	if (SensorValue(lightsensor) < threshold)
	{
		// Sensor detects the black cell.
		nxtDisplayCenteredTextLine(4, " Black Cell Detected ");
		wait1Msec(400);
		return 1;
	}
	else
	{
		// Sensor detects the white cell.
		nxtDisplayCenteredTextLine(4, " White Cell Detected ");
		wait1Msec(400);
		return 0;
	} //end else
}//end check_cell

//updates the map for black cells
void update_map( int current_x, int current_y, int direction )
{
	if (direction == 0)
	{

		//Facing north, so row above, same column is black
		grid[current_x][current_y+1] = 1;

	}//end if

	else if (direction == 1)
	{

		//Facing west, so same row, previous column is black
		grid[current_x-1][current_y] = 1;

	}//end else

	else if (direction == 2)
	{

		//Facing south, so row below, same column is black
		grid[current_x][current_y-1] = 1;

	}//end else if

	else if (direction == 3)
	{

		//Facing east, so same row, next column is black
		grid[current_x+1][current_y] = 1;

	}//end else if

	printmap();

}

void update_map_for_object( int current_x, int current_y, int direction, int no_of_blocks )
{
	if (direction == 0)
	{

		//Facing north, so row above, same column is object
		grid[current_x][current_y+no_of_blocks] = 2 ;

	}//end if

	else if (direction == 1)
	{

		//Facing west, so same row, previous column is object
		grid[current_x-no_of_blocks][current_y] = 2;

	}//end else

	else if (direction == 2)
	{

		//Facing south, so row below, same column is object
		grid[current_x][current_y-no_of_blocks] = 2;

	}//end else if

	else if (direction == 3)
	{

		//Facing east, so same row, next column is the object
		grid[current_x+no_of_blocks][current_y] = 2;

	}//end else if

	nxtDisplayClearTextLine(7);
	nxtDisplayCenteredTextLine(4, "Object No. 1 Found");
	wait1Msec(2000);
	printmap();

} //end update_map for object

//function to turn left
void turnleft()
{

	nMotorEncoder[rightmotor] = 0;
	while(nMotorEncoder[rightmotor] < 175)
	{

		motor[leftmotor] = -speed;
		motor[rightmotor] = speed;

	} //end while

	motor[rightmotor] = 0;
	motor[leftmotor] = 0;
	wait1Msec(400);

}//end turnleft

//function to turn right
void turnright()
{

	nMotorEncoder[leftmotor] = 0;
	while(nMotorEncoder[leftmotor] < 175)
	{

		motor[leftmotor] = speed;
		motor[rightmotor] = -speed;

	} //end while

	motor[rightmotor] = 0;
	motor[leftmotor] = 0;
	wait1Msec(400);

}//end turn right

//function to move forward
void forward()
{

	nMotorEncoder[rightmotor] = 0;
	while(nMotorEncoder[rightmotor] < 270)
	{

		motor[leftmotor] = speed;
		motor[rightmotor] = speed;

	}//end while
	motor[rightmotor] = 0;
	motor[leftmotor] = 0;
	wait1Msec(500);

}//end forward

void change_direction()
{
	int cell_colour;
	//random function.
	random_var = rand() % 2 + 1;

	//if the random_var is 0 turn left
	if( random_var == 0 )
	{
		turnleft();
		direction++;

		//if direction is 4 it means it facing north so change the direction value to 0
		if( direction == 4 )
		{
			direction = 0;
		}//end inner if

		cell_colour = check_cell( thresholdValue );

		//if its detecting black cell change direction again.
		while(cell_colour == 1)
		{
			cell_colour = check_cell( thresholdValue );
			change_direction();
		}

	}//end if

	//if the random_var is 1 turn right
	if( random_var == 1 )
	{
		turnright();
		direction--;

		//if direction is -1 it means the the user is facing east changes the direction value to 3
		if(direction == -1 )
		{
			direction = 3;
		}//end inner if

		cell_colour = check_cell( thresholdValue );

		//if its detecting black cell change direction again.
		while(cell_colour == 1)
		{
			cell_colour = check_cell( thresholdValue );
			change_direction();
		}

	}//end if

}//end change direction

//function to move around the grid to find the objects,avoiding black cells and updating the map.
void navigate()
{
	int cell_colour;

	//checks the cells infront
	cell_colour = check_cell( thresholdValue );

	if (cell_colour == 1)
	{
		//checks the sonar sensor if its detecting an object
		check_all_sides();
		
		//before moving forward checks first if the robot is in the edge.
		check_edge();

		// Since Black cell was detected have to change th
		update_map(current_x, current_y, direction);

		//Need to avoid obstacle
		change_direction();

		//change coordinates
		change_coordinates();

		forward();

	}
	else
	{
		
		//checks the sonar sensor if its detecting an object
		check_all_sides();
		
		//before moving forward checks first if the robot is in the edge.
		check_edge();
		
		//change the current_x / current_y when it moves forward.
		change_coordinates();

		//moves forward.
		forward();

	}//end else

}//end navigate.

//check if the robot is on the edge of the grid.
void check_edge()
{
	while( direction == 0 && current_y == 8) //checks if at north edge & change direction if it is
	{
		//checks the direction of the robot
		change_direction();
		check_cell( thresholdValue );
	}

	while( direction == 1 && current_x == 0) //checks if at west edge & change direction if it is
	{
		//checks the direction of the robot
		change_direction();
		check_cell( thresholdValue );
	}

	while( direction == 2 && current_y == 0 ) //checks if at east edge & change direction if it is
	{
		//checks the direction of the robot
		change_direction();
		check_cell( thresholdValue );
	}

	while( direction == 3 && current_x == 6 ) //checks if at south edge & change direction if it is
	{
		//checks the direction of the robot
		change_direction();
		check_cell( thresholdValue );
	}
}

//change the coordinates of the robot when it moves forward.
void change_coordinates()
{
	if( direction == 0 ) //facing north
	{
		current_y++; //change y position
	}
	else if( direction == 1 ) //facing west
	{
		current_x--; //change x position
	}
	else if( direction == 2 ) //facing south
	{
		current_y--; //change y position
	}
	else if( direction == 3 ) //facing east.
	{
		current_x++; //change x position
	}
}

void check_touch()
{
	//it detects an object
	if(SensorValue(touchsensor) == 1)
	{
		found_objects++;
		update_map_for_object( current_x, current_y, direction,no_of_blocks );
		nxtDisplayClearTextLine(4);
		nxtDisplayCenteredTextLine(4, "Found object %d",found_objects);
		wait1Msec(500);
	}
}

//function to move back to the start position
void move_to_start()
{

	//make the robot facing where the start position is
	while( direction != 2 )
	{
		turnleft();
		direction++;
		if( direction == 4 )
		{
			direction = 0;
		}
	}
	//while the robot is not on y axis of 0 forward
	while( current_y != 0 )
	{
		forward();
		change_coordinates();
	}
	//if the robot is on the x of less than 4 turn left.
	if( current_x < 4 )
	{
		turnleft();
		direction++;
		if( direction == 4 )
		{
			direction = 0;
		}
		while( current_x != 4 )
		{
			forward();
			change_coordinates();
		}
	}
	//else if the robot is on the x that is greater than 4 turn right.
	else if( current_x > 4 )
	{
		turnright();
		direction--;
		if( direction == -1 )
		{
			direction = 3 ;
		}
		while( current_x != 4 )
		{
			forward();
			change_coordinates();
		}
	}
	//make the robot turn north again.
	while( direction != 0 )
	{
		turnright();
		direction--;
		if( direction == -1 )
		{
			direction = 3 ;
		}
		while( current_x != 4 )
		{
			forward();
			change_coordinates();
		}//end inner while
	}//end while
}//end move_to_start.


//function to detect the objects using sonar sensor.
void detect_objects( int no_of_blocks )
{

	sonarvalue = SensorValue(sonarsensor);

	if( sonarvalue <= 20 )
	{
		no_of_blocks = 2;
		found_objects++;
		update_map_for_object( current_x, current_y, direction, no_of_blocks );
	}
	else if( sonarvalue <= 30 )
	{
		no_of_blocks = 3;
		found_objects++;
		update_map_for_object( current_x, current_y, direction, no_of_blocks );
	}
	else if( sonarvalue <= 40 )
	{
		no_of_blocks = 4;
		found_objects++;
		update_map_for_object( current_x, current_y, direction, no_of_blocks );
	}
	else if( sonarvalue <= 50 )
	{
		no_of_blocks = 5;
		found_objects++;
		update_map_for_object( current_x, current_y, direction, no_of_blocks );
	}
	else if( sonarvalue <= 60 )
	{
		no_of_blocks = 6;
		found_objects++;
		update_map_for_object( current_x, current_y, direction, no_of_blocks );
	}
	else if( sonarvalue <= 70 )
	{
		no_of_blocks = 7;
		found_objects++;
		update_map_for_object( current_x, current_y, direction, no_of_blocks );
	}

	wait1Msec(500);

}

void check_all_sides()
{
	turnleft();
	direction++;
	detect_objects( no_of_blocks );
	if( direction == 4 )
	{
		direction = 0;
	}
	turnright();
	direction--;
	detect_objects( no_of_blocks );
	if( direction == -1 )
	{
		direction = 3;
	}
	turnright();
	direction--;
	detect_objects( no_of_blocks );
	if( direction == -1 )
	{
		direction = 3;
	}
	turnleft();
	direction++;
	detect_objects( no_of_blocks );
	if( direction == 4 )
	{
		direction = 0;
	}
}

//function to print the map in the nxt
void printmap()
{
	int line = 10;

	for(int i = 0; j < 9; j++)
	{
		string print = "" ;

		for(int j=0; j < 7; j++)
		{
			if(grid[i][j] == 99)
			{
				print = print + "S ";
			}
			else if(grid[i][j] == 1)
			{
				print = print + "0 ";
			}
			else if(grid[i][j] == 2)
			{
				print = print + "X ";
			}
		}
		nxtDisplayString(line, print);
		line--;
	}

	nxtDisplayString(1,"X: %d		Y: %d", current_x,current_y );

}
